---
layout: post
title: 석사 연구 정리(1) - 리버스 엔지니어링

excerpt: 석사 연구 정리(1) - 리버스 엔지니어링

date: 2024-08-26
last_modified_at: 2024-08-26
---
석사 과정 연구 중 공부 및 연구한 내용을 정리하였다.

<H2>리버스 엔지니어링</H2>
리버스 엔지니어링이란 어떤 제품이나 시스템의 구조, 기능, 작동 원리 등을 파악하기 위해 이를 분해하고 분석하는 과정을 말한다. 프로그래밍에서 리버스 엔지니어링은 프로그램의 동작 및 알고리즘을 분석하기 위해 이루어진다.
대부분의 소프트웨어가 소스코드가 아닌 바이너리 형태로 배포되기 때문에 리버스 엔지니어링은 주로 바이너리 코드를 대상으로 이루어지며, 이를 위한 도구/기법들 또한 존재한다(디컴파일러 등).

<H3>어셈블리 언어</H3>
어셈블리는 리버스 엔지니어링을 위한 가장 기초적인 도구 중 하나이다.
어셈블리 언어는 기계어 바로 윗 단계의 저급 프로그래밍 언어로서, cpu의 명령어와 1대 1로 대응되어 1 라인이 cpu의 한 명령을 나타낸다. 바이너리를 어셈블리 코드로 변환하는 것을 디스어셈블리라고 부르며, cpu 명령어와 1대 1로 대응되기 때문에 난독화 되지 않은 코드에 대해서 쉽고 정확하게 변환 가능하다.
어셈블리 언어는 cpu 아키텍처의 지원 명령어셋에 따라 다른 명령어를 가지며, 인텔, AT&T등 여러 표기법이 존재한다. 본 포스팅은 인텔의 32비트 표기법(IA-32)를 기반으로 설명한다.

기본적인 어셈블리어의 표기법은 다음과 같다.
```
"명령어(opcode)" "인자 (operand) 1", "인자 2", ....

**여기서 인자의 개수는 명령어의 필요 인자 개수에 따라 달라진다. 대부분의 명령어는 1개 혹은 2개의 인자를 가지며 극소수의 명령어가 0개 혹은 3개 이상의 인자를 가진다.
ex) add eax, 0x1 => 0x1을 eax 레지스터에 합산
    push 0x1 => 스택에 0x1을 push
```
기본적으로 고급 프로그래밍 언어의 함수와 유사하나, 어셈블리어는 cpu가 직접 수행하는 명령어만을 지원한다는 차이점이 존재한다.
이로 인해 어셈블리어는 변수의 레지스터, 메모리 할당, 주소 연산 등 모든 과정을 어셈블리어 내에서 모두 구현하여야 하며, 코드의 분석 난이도 또한 자연스레 올라가게 된다.


<H3>레지스터 및 메모리</H3>
레지스터는 cpu 내에서 이용되는 변수이다. cpu는 기본적으로 동작에 필요한 8개의 레지스터를 가진다.

*EAX, EBX, ECX, EDX
  - 위 네 레지스터는 고급 언어의 변수와 같이 연산에 주로 사용된다. 유의할 점은 EAX는 주로 산술 연산 및 리턴값 저장에 이용되고 ECX는 반복문 count에 주로 이용된다는 점이 있다.
  - 위 레지스터들은 x, l, h 하위 레지스터를 가진다. 각 하위 레지스터를 통해 EAX 내부의 16비트, 8비트 영역에 접근 가능하다.
  - ![image](https://github.com/user-attachments/assets/c682fe86-3498-4667-bce3-b90c70a2c914)
  - (이미지 출처 stackoverflow: https://stackoverflow.com/questions/15191178/how-do-ax-ah-al-map-onto-eax)

*ESI,EDI
  - 문자열과 같이 긴 데이터를 처리하는데 이용된다.
  - ESI(Source Index)와 EDI(Destination Index)는 긴 데이터 스트림의 메모리 주소의 시작점, 목적지를 저장한다. memcpy의 동작과정과 유사하며,실제로 memcpy에서 이용된다.

*ESP,EBP
  - 현재 연산중인 스택 포인터 주소 및 베이스 포인터를 저장한다.
  - 시스템 프로그래밍에서 배우는 스택 프레임 연산에서 이용된다.
  - ![image](https://github.com/user-attachments/assets/8b1b9ad1-7717-4a32-8333-a7263bc47dad)
  - 이미지 출처 velog : https://velog.io/@weweweme/%EC%8A%A4%ED%83%9D-%ED%94%84%EB%A0%88%EC%9E%84Stack-Frame%EC%9D%B4%EB%9E%80

<H3>함수의 시작, 종료 구조 예시</H3>
* 시작 코드
  - ebp에 저장된 이전 스택프레임의 베이스 포인터를 스택에 push
  - esp의 값을 ebp로 복사해 새로운 스택 프레임으로 이동
  - esp에 뺄셈 연산 통해 새로운 스택 프레임 공간 할당 (프레임은 작은쪽 주소 방향으로 커짐)
  ```
  push ebp
  move ebp, esp
  sub esp, 0x12
  ```
* 종료 코드
  - 현재 ebp 값을 esp로 복사하여 이전 스택 프레임의 종료점으로 이동 
  - pop을 통해 스택에 저장된 이전 스택 프레임 베이스 값을 ebp에 가져와 이전 스택 프레임을 복구

<H3>반복문과 분기문</H3>
기본적으로 어셈블리어는 c언어와 같은 for, if문이 존재하지 않는다. 어셈블리어는 이를 구현하기 위해 goto와 유사한 방식을 사용한다. cmp 등 비교 연산자를 통해 조건식을 비교하고, 조건부 jmp문을 통해 분기 및 반복을 수행한다.

<H3>디스어셈블리 툴</H3>
현재 많은 디스어셈블리 도구가 공유/ 상용화되어있다. 대표적으로 IDA, Ghidra 등이 있으며, IDA는 플러그인을 통해 디컴파일(바이너리를 고급 언어로 변환)을 지원한다.
이 외에 radare, binarininja, angr 및 여러 도구가 존재하며, 아래 링크와 같이 온라인으로 여러 디스어셈블러를 통한 디스어셈블을 지원하는 사이트도 존재한다.

https://dogbolt.org/

참고서적 - 리버스 엔지니어링 바이블 / 위키북스/ 강병탁
